## 2023/6/10(土)

## 取り組んだ課題

- タイピング練習
- 「GitHub & Pull Request」視聴

## わかったこと

- 「GitHub & Pull Request」視聴

  - Pull と Push の非対称性
    - Pull：リモートブランチを持ってきてマージする
      - リモートリポジトリに対する Read 権限だけあればよい
      - 手元で変更が加えられていても良い
    - Push：リモートブランチを送信する
      - リモートリポジトリに対する Write 権限が必要
      - リモートで変更が加えられていると失敗する
      - "![rejected] dev -> dev(non-fast-forward)"
    - ある変更を開発者間で伝達する：Pull が基本
      - Pull Request は存在するが、Push Requst は無い
  - GitHub
    - Git を核とした開発プロジェクトのためのサイト
      - Git リポジトリ
      - リポジトリのフォーク(clone +α)
      - Pull Request
      - バグトラッキングシステム(Issues)
      - Wiki
      - ビルド自動化支援
      - プロジェクト管理
    - 2018 年に Microsoft が GitHub 者を買収
  - GitHub と中央集中型バージョン管理
    - GitHub により中央集中型と同様の管理が可能
    - 各個人は手元に GitHub 上のリポジトリを複製
      - 更新の登録・取得は手元のリポジトリが対象
      - 手元のリポジトリを GitHub 上のリポジトリへ反映
    - 互いのマシン同士が疎通しなくても大丈夫
  - Fork(フォーク)
    - 本家(メインストリーム)から派生する機能
    - フォークする理由は様々
      - 本流のメンテが止まってしまった
      - 開発方針の相違により分家する
      - 本流をベースに差分開発をしたい
        - あるソフトウェアをベースにして自分たちの作りたいものを作る
    - Git の clone に似ている
      - 違い１：フォーク先のページにフォーク元が表示される
      - 違い２：フォーク元からフォーク先のリポジトリに飛べる
      - 違い３：フォーク先からフォーク元への PR が簡単に作れる
    - GitHub Actions
      - ビルド自動化支援の仕組み
      - Push などのタイミングで、GitHub 側で任意のコマンドを実行できる
      - ビルドして、成果物をサイトに公開するまでを自動化
        → 継続的にインテグレーション、継続的デリバリー
    - ブランチのモデル
      - ブランチの使い方を規定するモデル
      - 複数の開発者が無秩序にブランチを作ると混乱する
      - 代表的なモデル２つ
        - Git-flow
          - 2010 年に発表された手法
          - ブランチモデルの元祖
          - 重たいソフトウェア向け
            - 明確にバージョンが付き
            - 長期間のテスト期間があり
            - 複数バージョンを並行して保守するソフトウェア
          - 日に何度もリリースするような開発には不適
        - GitHub flow
          - Main ブランチ+機能ブランチ(複数)
            - Main ブランチを常にリリース可能状態に保つ
            - 機能ごとにりりーするプロダクトに向く
          - 頻繁にリリースするプロダクトに向く
    - チーム開発と Pull Request
      - チーム開発では他人の力を借りられる
      - レビューによりコード品質を高められる
      - Pull Requesr 内でコードにコメントを付けられる
        - レビュー行為がしやすい
      - LGTM(Looks Good To Me)
        - コードに対して「私はいいと思います」という意思表明
      - 一通り問題が解決したら Pull Request 上でマージ操作
    - レビュー
      - ピアレビュー(Peer Review)
        - 同じ立場の同僚(Peer)が行うレビュー
        - 論文なら査読
      - 話題は多岐にわたる
        - コードスタイル(インデント)、誤字脱字
        - 関数やモジュールへの分割
        - プログラムの論理構造、全体設計
      - コードスタイルや誤字脱字をなるべく少なくしよう
        - それらが残っていると枝葉末節の議論をしがち
        - 綺麗なコードなら大きなところに目がいく
    - リポジトリ間 Pull Request
      - 異なるリポジトリ間の Pull Request
      - OSS の開発でよく使う
        - 一般の開発者は公式リポジトリへの書き込み権限を持たない
  - Learn Git Branching
    - ブランチ
      - 早めに、かつ頻繁にブランチを切る
        - どれほど多くのブランチを作ってもストレージやメモリを全然使わないので、ブランチを肥大化させるよりも論理的に分割していく方が簡単
    - HEAD
      - 現在チェックアウトされている(今作業中の)コミットを指す
    - git reset
      - ブランチのポインタを後方に移動することで変更のキャンセルを実現する(履歴の上書きのようなもの)
      - そもそも前のコミットなんかなかったかのように、ブランチのポインタを元に戻してくれる。
    - git revert
      - 巻き戻したいと思ってたコミットの下に新しいコミットが出来上がる
      - 巻き戻した内容を他人と共有するためには revert を使用する
    - git cherry-pick
      - git cherry-pick <Commit1> <Commit2> <...>
      - 現在の位置(HEAD)の下に一連のコミットをコピーしたいという意を単純に表す方法
    - git describe
      - git describe <参照>
      - <参照>には、Git が解釈可能なコミットの参照表現（ブランチやタグの指定、コミットハッシュなど）を入れる。
        もし、何も入力しなかった場合、Git は現在の位置のコミット（HEAD）を使用する。
      - コマンドの結果
        - <タグ>\_<コミット数>\_g<ハッシュ>
        - <タグ>には履歴の一番最新のタグ名が、<コミット数>にはそのタグから幾つのコミットがあったか、<ハッシュ>はそのコミットのハッシュがそれぞれ入る。
      - 最も近く関係のある「アンカー」（タグの別名）を記述する(対象のブランチの最新のタグ名を確認できる)ためのコマンド

## 感じたこと

- 「GitHub & Pull Request」視聴
  - LGTM はコードのレビューイのモチベーションやチーム内の雰囲気を良くするために必要不可欠だと感じた。
  - Git-flow と GitHub flow の違いはリリースまでのスピード感だと思うが、アジャイル開発の場合だろ GitHub flow を使用する〜みたいな感じなのか気になった。
  - Fork という機能があることやそれが GitHub 独自の機能であることも初めて知った。普段の業務では使用しなさそうだが、自分で OSS の差分を回春する機会が生じた場合は使用していきたい。
- Learn Git Branching
  - Learn Git Branching で rebase や cherry-pick、revert などのコマンドを視覚的に練習することで実際にコマンドがどのような動きを行っているのか理解が深まった。
  - cherry-pick や revert コマンドは Udemy の「Git： もう怖くない Git！チーム開発で必要な Git を完全マスター」でも取り上げられていなかったので新たに勉強になった。また、チームで開発する場合は git reset だとコミット自体が削除されて履歴が残らないため git revert で履歴を残せるほうがいいのではないかと感じた。

## 次やること

- Linuc の問題集
- Learn Git Branching の続き

## 勉強時間

- Today: 5.0h
- Total: 98.5h
