## 2023/6/7(水)

## 取り組んだ課題

- タイピング練習
- 「Git： もう怖くない Git！チーム開発で必要な Git を完全マスター」視聴
  - セクション 3~セクション 7 まで

## わかったこと

- 「Git： もう怖くない Git！チーム開発で必要な Git を完全マスター」視聴

  - ファイルへの変更を取り消す
    - git checkout コマンド
      - git checkout -- <ファイル名>
      - git checkout -- <ディレクトリ名>
    - 全変更を取り消す
      - git checkout -- .
  - ステージに追加した変更をもとに戻したいとき
    - git reset コマンド
      - git reset HEAD <ファイル名>
      - git reset HEAD <ディレクトリ名>
    - 全変更を取り消す
      - git reset HEAD .
    - 指定した変更をステージから取り消すだけなので、ワークツリーのファイルには影響を与えない。
  - HEAD は今自分がいるブランチの最新のコミット
  - 直前のコミットを修正したい
    - git commit --amend
    - リモートリポジトリに Push したコミットはやり直してはダメ。
  - GitHub とのやり取り
    - リモートを表示する
      - git remote
      - 対応する URL を表示
        - git remote -v
    - リモートリポジトリを追加する
      - リモートリポジトリは複数登録できる
        - チーム開発とは別に自分のリモートリポジトリを持っておきたい場合
        - 複数のチームそれぞれでリポジトリを持っている場合
      - git remote add <リモート名> <リモート URL>
      - 例：git remote add tutorial https://github.com/user/repo.git
    - リモートから情報を取得
      - フェッチ
        - git fetch <リモート名>
          - git fetch をするとリモートリポジトリからローカルリポジトリに情報を取得してくるが、ワークツリーには反映されない。
          - ローカルリポジトリの remotes/リモート/ブランチという場所に保存されている。
          - 自分のワークツリーにも反映させたい場合は git merge コマンドを使用してリモートの情報をワークツリーにマージ（統合）させていく。
    - リモートから情報を取得してマージまでを１度にやりたいとき
      - プル
        - git pull <リモート名> <ブランチ名>
          - 下記コマンドと同じことをしている
            - git fetch origin master
            - git merge origin/master
        - git pull のように省略可能
    - フェッチとプルの使い分け
      - フェッチを基本的に使うのがおすすめ。プルは挙動が特殊。
      - プルの注意点
        - 自分が今いるブランチを間違えていた場合、取り込みたくないブランチにリモートリポジトリの内容をマージしてしまう。
        - 自分が master ブランチにいてなんの変更もしていない場合に限ってプルして情報を取得するのが安全でおすすめ。
    - リモートの詳細情報を取得する
      - git remote show <リモート名>
      - git remote コマンドより詳しい情報を取得
        - Fetch と Push の URL
        - リモートブランチ
        - git pull の挙動
        - git push の挙動
    - リモート名を変更、削除
      - 別のリモート名を使用したいとき、リモートが要らなくなったときに使用する。
      - 変更
        - git remote rename <旧リモート名> <新リモート名>
      - 削除
        - git remote rm <リモート名>
    - ブランチ
      - 並行して複数機能を開発するためのもの。
      - ブランチを分岐させることで、自分の開発に他の人の変更が影響を与えなくなる。
      - ブランチの仕組み
        - ブランチはコミットを指し示したポインタ。
        - HEAD は今自分が作業しているブランチを指し示したポインタ。
        - 新しくコミットしたらブランチが指し示すコミットファイルが変わる。
          - ブランチはあくまでコミットを指し示すポインタに過ぎない。
          - ブランチはコミット ID を記録したポインタ。
          - HEAD の中身も「ref:feature」のように現在作業しているブランチのファイル名が書かれている.
      - 新しいブランチを作成
        - git branch <ブランチ名>
        - ブランチを作成するだけで切り替えは行わない。
      - ブランチの一覧を表示する
        - git branch
        - 全てのブランチを表示する
          - git branch -a
      - ブランチを切り替える
        - git checkout <既存のブランチ名>
        - ブランチを新規作成してきりかえる
          - git checkout -b <新ブランチ名>
    - マージ
      - git merge <ブランチ名>
      - git <リモート名/ブランチ名>
      - GitHub にあるマスターブランチの内容を自分の作業中のブランチにマージする。
      - 他のブランチの変更分を自分の手元に取り込めることが重要。
      - マージには取り込み方が３種類ある。
        - Fast Forward(早送りになるマージ)
          - 元々の master ブランチの先に hot fix ブランチがあった(枝分かれしていない)場合にブランチのポインタが前に進むだけ。
        - Auto Merge(基本的なマージ)
          - master ブランチと feature ブランチが枝分かれして開発していた場合にマージコミットという新しいコミットファイルが作られる。通常のコミットファイルとは parent を２つ持っている点が違う。
        - コンフリクト
          - 複数人の人が同じ箇所で別々の変更をした時にどの変更を優先していいかわからない状態
          - コンフリクトの解決の仕方
            - 最終的なファイル内容を記載すれば OK
          - コンフリクトが置きないようにするには
            - 複数人で同じファイルを変更しない
            - pull や merge をする前に変更中の状態を無くしておく(commit や stash をしておく)
            - pull するときは pull するブランチに移動して pull する
        - ブランチ名を変更・削除
          - 変更(今いるブランチ名を変更)
            - git branch -m <ブランチ名>
          - 削除
            - git branch -d <ブランチ名>
            - 強制削除
              - git branch -D <ブランチ名>
    - ブランチを利用した開発の流れ
      - master ブランチをリリース用ブランチに開発はトピックブランチを作成して進めるのが基本
        - 開発したい内容に合わせてトピックブランチを作成し、開発が終了したらトピックブランチをマスターブランチにマージしてリリース
        - master ブランチを今リリースされているもの（最新の状態）にしておける
    - リモートブランチ
      - リモートブランチとはリモートのブランチの状態へのポインタ
      - git fetch すると fetch してきた内容は「origin/<ブランチ名>」の形で保存されている
  - GitHub を利用した開発手順の流れ
    - プルリクエストの流れ
      - プルリクエスト
        - 自分の変更したコードをリポジトリに取り込んでもらえるよう依頼する機能
        - コードレビューを挟むためにある
        - プルリクエストの手順
          1. master ブランチを最新に更新
          2. ブランチを作成
          3. ファイルを変更
          4. 変更をコミット
          5. GitHub へプッシュ
          6. プルリクエストを送る
          7. コードレビュー
          8. プルリクエストをマージ
          9. ブランチを削除
    - GitHub Flow の流れ
      - GitHub Flow とは GitHub 者が用いている GitHub 社のワークフロー
        - まず master ブランチがあり、何か開発するときはマスターブランチからその開発用のブランチを切っていく。
        - 開発が完了したらその開発ブランチからマスターブランチにプルリクエストを送る。
        - プルリクエストを送ってコードレビューは完了し、承認されたらそのブランチを master に merge してリリースしていく。
      1. master ブランチからブランチを作成
      2. ファイルを変更しコミット
      3. 同名のブランチを GitHub へプッシュ
      4. プルリクエストを送る
      5. コードレビューし、master ブランチに merge
      6. master ブランチをデプロイ
      - GitHub Flow を実践する上でのポイント
        - master ブランチは常にデプロイできる状態に保つ
        - 新開発は master ブランチから新しいブランチを作成してスタート
        - 作成した新しいブランチ上で作業しコミットする
        - 定期的に Push する(他のチームメンバーがどんな作業をしているか把握できる)
        - master にマージするためにプルリクエストを使う
        - 必ずレビューを受ける
        - master ブランチにマージしたらすぐにデプロイする → テストとデプロイは自動化

## 感じたこと

- 「Git： もう怖くない Git！チーム開発で必要な Git を完全マスター」視聴

  - pull と fetch+merge の挙動については曖昧になっている所があったので非常に勉強になった。
  - コミットについては自分は塊単位で行っているが、実際何がベストなのか日はよくわかっていなかったのでいくつか記事を読んでみた。

    - [[Git]コミットの粒度の肝はレビュワーを常に意識すること](https://blog.masuyoshi.com/git%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88%E3%81%AE%E7%B2%92%E5%BA%A6%E3%81%AF%E3%83%AC%E3%83%93%E3%83%A5%E3%83%AF%E3%83%BC%E3%82%92%E5%B8%B8%E3%81%AB%E6%84%8F%E8%AD%98/)
      - コミットの粒度が必要になるのは、「誰かがあなたのコードを読んでくれる時」
      - コミットをカテゴリに分ける。（feat(新機能追加)、fix(バグ修正)、docs(コメントアウトのみ追加、javadoc 形式でコメントを書いたなど)）
      - 「ざっと見で無視してもよい箇所」「しっかり見てもらいたい箇所」「メソッド単位」という指針は重要。
      - 行単位で「こんな作業をした」「制御をいれ」「コメントを書いた」というコミットを行うと良い。
    - [Git 作業における commit と push の頻度について](https://qiita.com/kozyty@github/items/87fa95a236b6142f7c10)

      - コミットの最大粒度は 1 タスク
        - コミットが大きすぎると良い事何もない。
      - たとえタスクが途中でもキリが良ければ即コミット
        - サブタスク単位 とか 本日の作業終了時 など、キリが良いタイミングがあればガツガツコミットしていく。
      - コミットしたらプッシュしとこう
        - 途中のコードが見られるの恥ずかしい なんて考えずにプッシュする。
      - コミットの頻度を細かくすることで下記のようなメリットがある
        - 自身の見積もり精度やタスク管理能力向上
        - 複数タスクが混在したコミットは悪
        - コミットとタグの相性 UP
        - Pivotal などの外部サービスとの連携が容易
        - 履歴を参照する際のコスト低下(log, reset, bisect, rebase 時など）
        - 自分や他人がみても commit 内容の把握が容易
      - プッシュの頻度を細かくすることで下記のようなメリットがある
        - 大きなコンフリクト発生頻度低下
        - git pull の頻度も自然と上昇
        - チーム間での状況共有が容易
        - コードは即他人に晒すという意識向上

    - [【初心者向け】「コミットの粒度がわからない問題」の模範解答を考えてみた](https://qiita.com/jnchito/items/40e0c7d32fde352607be)
      - チケット単位、または戻したい単位でコミット
      - コミットはドラクエのセーブと同じ
        - 開発＝ここまで書いたコード、ここまで作った機能を失いたくない、と思ったらコミット
      - 正常に動く単位にする
      - TODO リスト単位でコミットする
        - 大きな機能を実装する前は TODO リスト（例：カラムを追加する、計算ロジックを実装する、画面を作成する、etc）を作成する
        - TODO リストの TODO を 1 つ終わらせるたびに 1 コミットする
      - コミットの前に機能ブランチを作る
    - [【Git】commit のタイミングと注意点](https://tech-blog.rakus.co.jp/entry/20190930/git)
      - 会社の規則に従う(会社で決まっているタイミングで行う)
      - 個人的に「この部分へは戻る可能性がある」と思ったとき
      - タスク単位(機能単位)※単一機能追加のみ
      - クラス単位(編集しているクラス 1 つにつき 1 回)

  - GitHub Flow については過去の現場でも使用していたため、すんなりと理解ができた。現場ではプッシュする前に orgin/release の変更を pull で取り込んでおくという方針があった。

## 次やること

- Linuc の問題集
- 「Git： もう怖くない Git！チーム開発で必要な Git を完全マスター」視聴
  - セクション 8~最後まで

## 勉強時間

- Today: 2.0h
- Total: 89.5h
