## 2023/11/23（木）

## 取り組んだ課題

- タイピング練習
- RESTについて学ぶ

## わかったこと

- RESTについて学ぶ
  - REST原則
    - 統一インターフェース
      - 4つの制約。
        - リソースの識別
          - リソースとは名前が付けられるあらゆるもの（ドキュメント、画像、人、情報、サービス、状態）。サーバー側に保持されるデータ。
          - URIを用いてサーバーに保存されたデータを識別する。URIに動作は含まない。
        - 表現を用いたリソース操作
          - 表現とはリソース（サーバーに保持されたデータ）のある断面。クライアントへ返されるレスポンスやサーバーへPOSTするデータ。
          - 断面情報を利用してサーバー上のデータを操作する。リソースのある断面が「表現」。
          - クライアントからサーバーへ編集リクエストをする際、認証情報を付与する。
        - 自己記述メッセージ
          - 自己記述はデータ自身がデータの中身を説明している。メッセージはサーバーへリクエストするデータ。クライアントへレスポンスするデータ。
          - メッセージ内容が何であるか、ヘッダーに記述されている。
          - レスポンスに含まれる情報（ヘッダー情報）で内容がどのようなものかわかる。
        - アプリケーション状態エンジンとしてのハイパーメディア（HATEOAS）
          - Hypermedia as the Engine of Application State
          - レスポンスに現在の状態を踏まえて関連するハイパーリンクが含まれている。
      - メリット
        - システムアーキテクチャ全体が簡素化されてわかりやすくなる。
        - 提供するサービスに集中でき、独自の進化ができる。
        - 異なるブラウザでも同じような画面を表示できる。
      - デメリット
        - 標準化によって効率が犠牲になる。
    - ステートレス
      - ステートフルとステートレス
        - ステートフル
          - ステートフルは前の状態を保存。
        - ステートレス
          - ステートレスは前の状態を保存しない。        
          - サーバーはリクエストだけでコンテキストを理解できる。
            - サーバーに保存されたコンテキスト情報を使わない（サーバーセッションは使わない）。
            - 状態はクライアント上に保存される（リクエストにすべて含める）。
      - メリット
        - 単一のリクエスト以外見る必要がないので、監視が容易。
        - 障害発生したリクエストだけ回復すればよいので、障害復旧が容易。
        - リクエスト全体でサーバーリソースを共有する必要がないのでスケールが容易。
      - デメリット
        - 単一のリクエストで完結させるため、リクエストデータに重複がある。
        - アプリを複数バージョン同時提供し、状態をクライアントにおいておくとアプリ制御が複雑になる。
    - キャッシュ制御
      - クライアントはレスポンスをキャッシュできる。
      - レスポンスは明示的または暗黙的にキャッシュ可能。
      - キャッシュを適切に行うことでクライアント/サーバー間の通信が排除され、ユーザー体験の向上、リソース効率の向上、拡張性の向上が見込める。
      - メリット
        - ユーザー体験の向上
        - リソース効率の向上
        - 拡張性の向上
      - デメリット
        - 古いデータを戻してしまうとシステムに対する信頼性の低下につながる
    - REST API成熟度モデル
      - 設計レベルは4段階。
      - LEVEL0・・・HTTPを使っている
        - REST APIの基本レベル。RPCスタイルのXML通信。
        - HTTTPは単なる通信手段として利用。
        - 1URLで全て完結。
        - リクエストボディーに処理と引数が含まれる。
      - LEVEL1・・・リソースの概念を導入
        - リソースごとにURLを分割。
        - HTTPメソッドは活用できていないので、GETかPOSTのみで通信。
      - LEVEL2・・・HTTPの動詞を導入
        - LEVEL1に加えてHTTPメソッドを活用。
        - リソースに対してHTTPメソッドを使ったCRUD操作が行われている。
      - LEVEL3・・・HATEOASの概念を導入
        - LEVEL2に加えてレスポンスにリソース間のつながりが含まれる。
        - レスポンスに現在の状態に関連するハイパーリンクが含まれている。（=HATEOASに相当する情報がレスポンスに含まれている）
  - REST WebAPIサービス設計（基本）
    - URIの設計
      - 短く入力しやすい（冗長なパスを含まない）
        - シンプルで覚えやすいもにすることで入力ミスを防ぐ
          - ✕ GET http://api.example/com/service/api/search
          - ◯ GET http://api.example/com/search
      - 人間が読んで理解できる（省略しない）
        - ✕ GET http://api.example/com/sv/u
        - ◯ GET http://api.example/com/users
      - 大文字小文字が混在していない（すべて小文字）
      - 単語はハイフンでつなげる
        - アンダースコアはタイプライターで下線を引くためのもの。ハイフンは単語をつなぐためのもの。
      - 単語は複数形を利用する
        - URIで表現しているのは「リソースの集合」
          - ✕ GET http://api.example/com/user/12345
          - ◯ GET http://api.example/com/users/12345
      - エンコードを必要とする文字を使わない
        - URIから意味が理解できない。
          - ✕ GET http://api.example/com/%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC
          - ◯ GET http://api.example/com/users
      - サーバー側のアーキテクチャが反映しない
        - 悪意あるユーザーに脆弱性を突かれる危険性がある
          - ✕ GET http://api.example/com/cgi-bin/get_user.php?id=12345
          - ◯ GET http://api.example/com/users/12345
      - 改造しやすい（Hackable）
        - システム依存の設計では意味が理解できない
          - ✕ GET http://api.example/com/items/alpha/12345
          - ✕ GET http://api.example/com/items/beta/23456
          - ◯ GET http://api.example/com/items/12345
      - ルールが統一されている
        - 一定のルールに従って設計することで間違いを防ぐ
          - ✕ GET http://api.example/com/friends?id=12345
          - ✕ GET http://api.example/com/friends/12345/message
          - ◯ GET http://api.example/com/friends/12345
          - ◯ GET http://api.example/com/friends/12345/messages
    - HTTPメソッドとURI
      - URIがリソースを示すのに対し、HTTPメソッドはリソースに対する操作を示す。
        - GET /v1/users/123 HTTP/1.1→ユーザー情報を取得
      - URIは同じでHTTPメソッドを変えることで操作を変える
        -  ユーザー情報一覧取得・・・GET http://api.example/com/users
        - ユーザーの新規登録・・・POST http://api.example/com/users
        - 特定ユーザーの取得・・・GET http://api.example/com/users/12345
        - ユーザーの更新・・・PUT http://api.example/com/users/12345
        - ユーザーの削除・・・DELETE　http://api.example/com/users/12345
    - クエリとパスの使い分け
      - リソースを特定するパラメータ
        - クエリパラメータ
          - URLの末尾にある"?"に続くキーバリュー。
            - GET http://api.example/com/users?page=3
        - パスパラメータ
          - URL中に埋め込まれるパラメータ。
            - GET http://api.example/com/users/123
      - クエリとパスの使い分け
        - クエリパラメータとするかどうかの判断基準
          - 一意なリソースを表すのに必要かどうか⇒パスパラメータを利用
          - 省略可能かどうか⇒クエリパラメータを利用
          - （例）検索条件（絞り込み条件）はパスに含めない
            - GET http://api.example/com/users?name=tanaka
    - ステータスコード
      - ステータスコードの役割
        - 処理結果の概要を把握するために必要。
      - ステータスコードの分類
        - 100番台・・・情報
          - 100 Cotinue・・サーバーがリクエストの最初の部分を受け取り、まだサーバーから拒否されていないことを示す。
          - 101 Switching Protocol・・・プロトコルの切り替え要求を示す。
        - 200番台・・・成功
          - 200 OK・・・ リクエストが成功したことを示す。本文にデータが含まれる。
          - 201 Created・・・リクエストが成功し、新しいリソースが作成されたことを示す。ヘッダーのLocationに新しいリソースへのURLを含める。
          - 202 Accepted・・・非同期ジョブを受け付けたことを示す。実際の処理結果は別途受け取る。
          - 204 No Content・・・リクエストは成功したが。レスポンスデータがないことを示す。クライアント側のビューを変更する必要がないことを示す。
        - 300番台・・・リダイレクト
          - API利用者はリダイレクトを実装していないことが多いのでREST APIでは基本的に3xxは利用しない。
        - 400番台・・・クライアントサイドに起因するエラー
          - 400 Bad Request・・・その他のエラー。
          - 401 Unauhorized・・・認証されていないことを示す。
          - 403 Forbidden・・・リソースに対するアクセスが許可されていない（認可されていない）ことを示す。
          - 404 Not Found・・・リクエストされたリソースが存在しないことを示す。
          - 409 Conflict・・・リソースが競合して処理が完了できなかったことを示す。
          - 429 Too Many Requests・・・アクセス回数が制限回数を超えたため処理できなかったこと（レートリミット）を示す。
        - 500番台・・。サーバーサイドに起因するエラー
          - 500 Internal Server Error・・・サーバーサイドのアプリケーションエラーが発生したことを示す。
          - 503 Service Unavailable・・・サービスが一時的に利用できないことを示す。メンテナンス機関や過負荷で応答できないようなケース。
    - HTTPメソッドとステータスコード
      - GET
        - データ取得
        - 成功
          - 200 OK
          - 304 Not Modified・・・キャッシュ利用
        - 失敗
          - 400 Bad Request・・・クライアント側のリクエスト不備
          - 401 Unauthorized・・・認証エラー
          - 403 Forbidden・・・認可エラー
          - 404 Not Found・・・該当データなし
          - 429 Too Many Requests・・・レートリミット制限
          - 500 Internal Server Error・・・サーバー障害
          - 503 Service Unavailable・・・高負荷で応答不可
      - POST
        - データ登録
        - 成功
          - 200 OK・・・レスポンスに登録済みデータも含む
          - 201 Created・・・レスポンスボディーが空。Locationに新しいリソースへのURL
          - 202 Accepted・・・非同期処理の受付が完了
        - 失敗
          - 400 Bad Request・・・クライアント側のリクエスト不備
          - 401 Unauthorized・・・認証エラー
          - 403 Forbidden・・・認可エラー
          - 409 Conflict・・・データが衝突
          - 429 Too Many Requests・・・レートリミット制限
          - 500 Internal Server Error・・・サーバー障害
          - 503 Service Unavailable・・・高負荷で応答不可
      - PUT
        - データ更新/データ登録
        - 成功
          - 200 OK・・・レスポンスに登録済みデータも含む
          - 201 Created・・・データ登録でレスポンスボディーにデータなし。Locationに新しいリソースへのURL
          - 204 No Content・・・データ更新でレスポンスボディーにデータなし
        - 失敗
          - 400 Bad Request・・・クライアント側のリクエスト不備
          - 401 Unauthorized・・・認証エラー
          - 403 Forbidden・・・認可エラー
          - 404 Not Found・・・該当データなし（データ更新で利用）
          - 409 Conflict・・・データが衝突
          - 429 Too Many Requests・・・レートリミット制限
          - 500 Internal Server Error・・・サーバー障害
          - 503 Service Unavailable・・・高負荷で応答不可
      - DELETE
        - データ削除
        - 成功
          - 200 OK・・・正常
          - 202 Accepted・・・非同期処理受付
          - 204 No Content・・・正常（できるだけこれで返す）
        - 失敗
          - 400 Bad Request・・・クライアント側のリクエスト不備
          - 401 Unauthorized・・・認証エラー
          - 403 Forbidden・・・認可エラー
          - 404 Not Found・・・該当データなし（403を隠すために利用）
          - 429 Too Many Requests・・・レートリミット制限
          - 500 Internal Server Error・・・サーバー障害
          - 503 Service Unavailable・・・高負荷で応答不可
    - データフォーマット
      - XML
        - テキスト形式
        - タグで記述
        - タグは入れ子にできる
        - タグに属性が付けられる
      - JSON
        - テキスト形式
        - JavaScriptを元にしたフォーマット
        - XMLに比べてデータ量が減らせる（=XMLタグは末尾にも同じ文字が必要なため冗長）
        - オブジェクトは入れ子にできる
      - JSONP
        - テキスト形式
        - データフォーマットのように見えるが「JavaScriptコード」
        - クロスドメインでデータを受け渡すことができる
      - データフォーマットの指定方法
        - クエリパラメータ
          - 実サービスで利用が多い
          - http://api.sample.com/v1/users?format=json
        - 拡張子
          - あまり見かけなくなった
          - http://api.sample.com/v1/users.json
        - リクエストヘッダー
          - URIがリソースであることを考えるとリソースヘッダーが一番お行儀が良い
          - Accept: application/json
    - データの内部構造
      - エンベロープは使わない
        - エンベロープ・・・レスポンスボディー内のメタ情報
        - ヘッダー情報と役割がかぶるのでエンベロープは使わない
      - オブジェクトはできるだけフラットにする
        - レスポンス容量を減らすため
      - ページネーションをサポートする情報を返す
        - 情報更新される可能性があるため、「"nextPage": 1」のような返し方はせず、「"hasNext": true, "nextPageToken": "FqTt82Cp"」のように次をどこから取得するのかキーとなる情報を返す。
      - プロパティの命名規則はAPI全体で統一する
        - 利用者が混乱するため。
      - 日付はRFC3339（W3C-DTF）形式を使う
        - インターネット標準的に用いられるため
        - ✕ RFC822（RFC1123）・・・Thu, 29 Mar 2018 08:00:00 GMT
        - ✕ RFC850・・・Thursday, 29-Mar-2018 08:00:00 GMT
        - ✕ Unixタイムスタンプ・・・1521781500
        - RFC3339（W3C-DTF）・・・2018-03-29T17:00:00+09:00
      - 大きな数値（64bit整数）は文字列で返す
        - JavaScriptで扱える演算可能な最大整数は9,0007,199,254,740,991
        - 通常のせいすうは32bitで64bit整数は処理できないため
    - エラー表現
      - エラー詳細はレスポンスボディーに入れる
        - 400だけだと何がダメかわからない
        - 足りない情報はレスポンスボディに追加する
      - エラーの際にHTMLが返らないようにする
        - レスポンスフォーマットが変わるとクライアントアプリ側で処理できないケースがある
      - サービス閉塞時は"503"+"Retry-After"
        - クライアント側から見ていつ再開してよいかわかる
  - REST WebAPIサービス設計（応用）
    - APIバージョンの表現
       - APIにバージョンを含めるか？
         - メリットは特定バージョン指定でアクセスできるので、クライアント側で突然エラーになる。デメリットは複数バージョンを並列稼働させるため、ソースコードやデータベースの管理が複雑になる
         - 広く世間一般に公開するようなサービスを展開するのであれば利用者の利便性を考慮してAPIバー呪怨を含めたURLの設計を行う
       - バージョンを入れる場所
         - バージョンを入れる場所は3種類
           - どのパターンも実例としては存在するが「パス」のケースが多い
           - HTTPのヘッダーに独自定義する場合。かつては"X-接頭辞"が推奨されていたが2012年6月以降は"X-接頭辞"は非推奨⇒サービス固有の接頭辞をつける
           - パス
             - http://api.sample.com/v1/users
           - クエリ
             - http://api.sample.com/users?version=1
           - ヘッダー
             - GET http://api.sample.com/users
             - X-Api-version: 1
       - バージョンの付け方
         - 「セマンティックバージョニング」がよく知られている
         - APIは後方互換しなくなったタイミングで付けるのがオススメ（=メジャーバージョンのみ利用）
         -  マイナーやパッチを付けているとその分管理が多くなってしまう。最低限守るのは後方互換しないメジャーの変更
    - OAuthとOpenID Connect
      - 認証と認可
        - 認証は「本人特定」、認可は「アクセス制御」
      - OAuthとOpenID Connectの違い
        - OAuthもOpenID Connectも認可の仕組み
        - OpenID ConnectはOAuthに本人情報取得を加えた仕組み
      - OAuth概要
        - Authorization Codeフローの場合
          - ①サードパーティアプリケーションに連携を依頼する
          - ②連携画面が表示される
          - ③ログイン
          - ④サービスからサードパーティアプリケーションに認可コードが発行される
          - ⑤サードパーティアプリケーションを認可コードを使用し、サービスに再度アクセスする。サービス側からアクセストークンというキー情報が返却される。アクセストークンは認可する範囲（=スコープ）を限定
          - ⑥サービスへAPIアクセスw/アクセストークンを渡す
      - OpenID Connect概要
        - codeフローの場合
          - ①サードパーティアプリケーションに連携を依頼する
          - ②連携画面が表示される
          - ③ログイン
          - ④サービスからサードパーティアプリケーションに認可コードが発行される
          - ⑤サードパーティアプリケーションを認可コードを使用し、サービスに再度アクセスする。サービス側からアクセストークンとIDトークンが返却される。IDトークンは認証結果情報であり、JSON Web Token（JWT）と呼ばれる形式となっている。
          - ⑥サービスへアクセストークンを渡すと個人情報用APIを利用して個人情報を取得する
    - JSON Web Token（JWT）
      - JSON Web Token（JWT）とは
        - 特徴は「署名による改ざんチェック」「URL-safeなデータ」「データの中身はJSON形式」の３つ
        - 用途は認証結果をサーバーサイドで保存せずクライアントサイトで保持（ステートレスな通信の実現）
      - 仕様
        - 基本構造
        - ヘッダー
          - 署名で利用するアルゴリズムなどを定義
          - typ
            - 名称はType、"JWT"固定
          - alg
            - 名称はAlgorithm、署名に利用するアルゴリズムで以下のようなアルゴリズムを使用可能
              - HS256・・・HMAC using SHA-256
              - RS256・・・RSASSA-PKCS1-v1_5 using SHA-256
              - ES356・・・ECDSA using P-256 and SHA-256
              - none・・・暗号なし（偽装できるので基本的に利用しない）
        - ペイロード
          - 保存したいデータの実態
          - 「予約済みクレーム」と「プライベートクレーム」の②種類がある
            - 予約済みクレーム
              - "iss"
                - Isuuerの略でJWTを発行しているサービス、システムの識別子を指す
              - "sub"
                - Subjectの略で同一Issuer内での識別子（該当サービスにおけるユーザーIDなど）を指す
              - "aud"
                - Audienceの略でJWTを利用しているサービス、システムの識別子を指す
              - "exp"
                - Expiration Timeの略でJWTの有効期限を指す
              - "jti"
                - JWT IDの略でJWTの再利用を防ぐために利用する一意識別子を指す
        - 署名
          - 改ざんされていないか確認するための署名
            - ALGORISM
              - ヘッダーの"alg"に指定したアルゴリズム
            - SECRET
              - アルゴリズムに合わせた鍵（秘密鍵 or 共通鍵）
      - jwt.io
        - JWTをWeb上の画面で確認できる
    - 大量アクセス
      - レートリミットとは
        - WebアプリをAPI化することで発生する問題は何でしょう？
          - API化により、簡単に大量アクセスするプログラムが書けたり、意図しないプログラマの不注意で大量アクセスが発生することがある。
            - 対応策としては時間あたりのアクセス制限をかける（=レートリミット）
      - レートリミットで考慮すること
        - 誰に対して・・・APIキー、ユーザーID...
        - 何に対して・・・単一機能、機能群、API全体...
        - 制限回数・・・10回、100回、1000回...
        - 単位時間・・・10分、1時間、1日...
          - 制限をリセットするタイミングでWindowとも呼ばれる
      - レートリミットアルゴリズム
        - Fiexd Window
        - Sliding Log
        - Sliding Window
      - アクセス制限の緩和措置
        - 接続元によっては特別な緩和措置が必要なケースがある
          - サービス利用が多く、自社にとって優良顧客である場合
          - キャンペーンなど、一時的に負荷増大がある場合
            - アクセス元ごとに一時的に時間変更できる仕組みを考慮する
    - キャシュ制御
      - キャッシュさせる方法
        - キャッシュ制御に利用するヘッダーは2分類3パターン
          - 有効期限による制御
            - Expires
              - キャシュとしていつまで利用可能の期限を指定
              - 過去日を指定すると「リソースが有効期限切れ」であることを意味知る
              - Cash-Controlが同時指定されている場合、Expiresは無視
            - Cache-Control+Date
              - Cache-Controlでキャッシュの「可否」「期限」を指定
          - 検証による制御
            - Last-Modified+ETag
              - Last-Modifiedにリソースの最新更新日時を指定
              - ETagに特定バージョンを示す文字列を指定
      - キャッシュさせる単位
    - セキュリティ
      - APIはどこから呼ばれるのか
        - 呼び出し元
          - スマホアプリ
          - Webページ
            - scriptタグ
            - JavaScript
           - 外部システム（バッチ）
        - APIにもWebサービスと同じセキュリティ対策が必要
      - XSS
        - 悪意あるユーザーが正規のサイトに不正なスクリプトを挿入することで、正規ユーザーの情報を不正に引き出したり操作できてしまう問題
        - 対策として以下を行う。
          - レスポンスヘッダーの追加
            - X-XSS-Protection・・・"1"でフィルタリング有効化
            - X-Frame-Options・・・"DENY"でframeタグ呼び出しを拒否
            - X-Content-Type-Options・・・"nosniff"でIE脆弱性対応
      - CSRF
        - 本来拒否しなければならないアクセス元（許可しないアクセス元）からくるリクエストを処理してしまう問題
        - 対策として以下を行う。
          - 許可しないアクセス元からのリクエストを拒否
            - X-API-Key・・・システム単位で実行可否判断
            - Authentication・・・ユーザー単位で実行可否判断
          - 攻撃者に推測されないトークンの発行/照合処理を実装
            - X-CSRF-TOKEN・・・トークンを使って実行可否判断
      - HTTP
        - 通信経路が暗号化されないので盗聴されやすい
          - 対策として以下を行う。
            - 常時HTTPSを利用した通信にする
            - SSL/TLS/HTTPSの違い
              - SSL・・・安全に通信を行うためのプロトコル。2015年に使用禁止
              - TLS・・・安全に通信を行うためのプロトコル。SSLの後継
              - HTTPS・・・HTTP+SSL/TLS。Webで安全に通信するプロトコル
      - JSON Web Token（JWT）
        - クライアント側で内容の確認/編集が簡単にできるため、サーバー側の検証が不十分だと改ざんされた情報を正規として受け入れてしまう
          - 対策として以下を行う。
            - ヘッダーのalgに"none"以外を指定して署名を暗号化する
            - ペイロードのaudに想定する利用者を指定して受信時に検証する

## 感じたこと 
- RESTについて学ぶ
  - サーバー上のリソースをURIで明確に識別し、表現を用いてデータを操作することが、効率的なWebサービスを実現する鍵であると感じました。
  - 統一インターフェースとステートレスな相互作用により、より拡張性が高く、保守しやすいWebアプリケーションが実現可能なのだなと感じました。

## 次やること

- RESTについて理解する
- テスト技法について学ぶ

## 勉強時間

- Today: 4.5h
- Total: 571.0h
